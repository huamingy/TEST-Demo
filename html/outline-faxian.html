<!-- @format -->

<!DOCTYPE html>
<html lang="en">
  <head>
    <title>22OutlineMeshBasicMaterial</title>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0" />
    <link type="text/css" rel="stylesheet" href="main.css" />
  </head>
  <body>
    <!-- Import maps polyfill -->
    <!-- Remove this when import maps will be widely supported -->
    <script async src="https://unpkg.com/es-module-shims@1.3.6/dist/es-module-shims.js"></script>

    <script type="importmap">
      {
        "imports": {
          "three": "../../../build/three.module.js"
        }
      }
    </script>

    <script type="module">
      // 引入 three 基础库
      import * as THREE from 'three';
      import Stats from '../../jsm/libs/stats.module.js';
      import {OrbitControls} from './../../jsm/controls/OrbitControls.js';

      let camera, renderer, scene, controls;
      let object;
      let stats;

      const params = {
        enableFpsRender: false,
        enableRightNowRender: false,
      };

      init();
      animate();

      function init() {
        // 渲染器
        renderer = new THREE.WebGLRenderer();
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setClearColor('#cccccc');
        document.body.appendChild(renderer.domElement);

        // camera
        camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 1, 1000);
        camera.position.z = 8;

        // 场景
        scene = new THREE.Scene();
        // 添加环境光
        scene.add(new THREE.AmbientLight(0x222222));
        // 添加方向光
        const light = new THREE.DirectionalLight(0xffffff);
        light.position.set(1, 1, 1);
        scene.add(light);
        // 窗口尺寸变化监听
        window.addEventListener('resize', onWindowResize);
        stats = new Stats();
        document.body.appendChild(stats.dom);
        controls = new OrbitControls(camera, renderer.domElement);

        // 添加物体到场景中
        object = new THREE.Object3D();
        scene.add(object);
        const geometry = new THREE.SphereGeometry(1, 4, 4);
        const material = new THREE.MeshPhongMaterial({color: '#ff3399', flatShading: true});
        const material2 = new THREE.MeshPhongMaterial({color: '#880088'});
        const mesh = new THREE.Mesh(geometry, material);
        mesh.position.set(-2, 0, 0);
        object.add(mesh);
        const mesh2 = new THREE.Mesh(geometry, material2);
        mesh2.position.set(2, 0, 0);
        object.add(mesh2);

        // 两种方式描边
        outlineMeshBasicMaterial(mesh, scene);
        OutLineNormalMaterial(mesh2, scene);
      }

      /**简单使用 MeshBasicMaterial 进行描边处理
       * @param {Object} mesh 要描边的物体
       * @param {Object} scene
       */
      function outlineMeshBasicMaterial(mesh, scene) {
        var outlineMaterial = new THREE.MeshBasicMaterial({color: 0xffffff, side: THREE.BackSide});
        var outlineMesh = new THREE.Mesh(mesh.geometry, outlineMaterial);
        outlineMesh.position.set(mesh.position.x, mesh.position.y, mesh.position.z);
        outlineMesh.scale.set(1.1, 1.1, 1.1);
        scene.add(outlineMesh);
      }

      /**
       * 简单使用 法线 进行描边处理
       * @param {Object} mesh 要描边的物体
       * @param {Object} scene
       */
      function OutLineNormalMaterial(mesh, scene) {
        var outlineMaterial = getOutLineNormalMaterial(0.1);
        var outlineMesh = new THREE.Mesh(mesh.geometry, outlineMaterial);
        outlineMesh.position.set(mesh.position.x, mesh.position.y, mesh.position.z);
        outlineMesh.scale.set(1.2, 1.2, 1.2);
        scene.add(outlineMesh);
      }

      /**
       * 简单发现扩展描边
       * @param {float} lineWidth 描边宽带
       * @param {float} lineAlpha 描边的透明度
       * @param {Object} lineColor 描边颜色
       */
      function getOutLineNormalMaterial(lineWidth = 1.0, lineAlpha = 1.0, lineColor = {r: 1.0, g: 1.0, b: 0}) {
        let uniforms = {
          lineWidth: {value: lineWidth},
          lineColor: {value: new THREE.Color(lineColor.r, lineColor.g, lineColor.b)},
          lineAlpha: {value: lineAlpha},
          timer: {value: 3.14},
        };

        let vertexShader = `
			  uniform float lineWidth;
			  void main()
			  {
			    gl_Position = projectionMatrix * modelViewMatrix * vec4( position + normal * lineWidth, 1.0 );
			  }
			  `;
        let fragmentShader = `
			  uniform vec3 lineColor;
			  uniform float lineAlpha;
			  uniform float timer;
			  void main(){
			    float factor = (sin(timer * 10.0 + 3.14 / 2.0) + 1.0) / 2.0;
			    float alpha = lineAlpha * factor;
			    gl_FragColor = vec4( lineColor , alpha);
			  }`;
        let material = new THREE.ShaderMaterial({
          uniforms: uniforms,
          vertexShader: vertexShader,
          fragmentShader: fragmentShader,
          side: THREE.BackSide,
          transparent: true,
        });
        return material;
      }

      function onWindowResize() {
        // camera 更新 aspect
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();

        // 渲染器更新大小
        renderer.setSize(window.innerWidth, window.innerHeight);
      }

      function animate() {
        requestAnimationFrame(animate);
        renderer.render(scene, camera);
        stats.update();
        controls.update();
      }
    </script>
  </body>
</html>
